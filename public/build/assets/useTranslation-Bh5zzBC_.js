import{d as f,z as j,B as F}from"./ContextMenuProvider-DoI9LuTu.js";const M=(e,t,a,n)=>{var s,d,w,h;const i=[a,{code:t,...n||{}}];if((d=(s=e==null?void 0:e.services)==null?void 0:s.logger)!=null&&d.forward)return e.services.logger.forward(i,"warn","react-i18next::",!0);N(i[0])&&(i[0]=`react-i18next:: ${i[0]}`),(h=(w=e==null?void 0:e.services)==null?void 0:w.logger)!=null&&h.warn?e.services.logger.warn(...i):console!=null&&console.warn&&console.warn(...i)},L={},E=(e,t,a,n)=>{N(a)&&L[a]||(N(a)&&(L[a]=new Date),M(e,t,a,n))},k=(e,t)=>()=>{if(e.isInitialized)t();else{const a=()=>{setTimeout(()=>{e.off("initialized",a)},0),t()};e.on("initialized",a)}},S=(e,t,a)=>{e.loadNamespaces(t,k(e,a))},A=(e,t,a,n)=>{if(N(a)&&(a=[a]),e.options.preload&&e.options.preload.indexOf(t)>-1)return S(e,a,n);a.forEach(i=>{e.options.ns.indexOf(i)<0&&e.options.ns.push(i)}),e.loadLanguages(t,k(e,n))},_=(e,t,a={})=>!t.languages||!t.languages.length?(E(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0):t.hasLoadedNamespace(e,{lng:a.lng,precheck:(n,i)=>{if(a.bindI18n&&a.bindI18n.indexOf("languageChanging")>-1&&n.services.backendConnector.backend&&n.isLanguageChangingTo&&!i(n.isLanguageChangingTo,e))return!1}}),X=e=>e.displayName||e.name||(N(e)&&e.length>0?e:"Unknown"),N=e=>typeof e=="string",G=e=>typeof e=="object"&&e!==null,$=f.createContext();class B{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(a=>{this.usedNamespaces[a]||(this.usedNamespaces[a]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const D=(e,t)=>{const a=f.useRef();return f.useEffect(()=>{a.current=e},[e,t]),a.current},P=(e,t,a,n)=>e.getFixedT(t,a,n),J=(e,t,a,n)=>f.useCallback(P(e,t,a,n),[e,t,a,n]),Y=(e,t={})=>{var z,O,R,v;const{i18n:a}=t,{i18n:n,defaultNS:i}=f.useContext($)||{},s=a||n||j();if(s&&!s.reportNamespaces&&(s.reportNamespaces=new B),!s){E(s,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const o=(u,l)=>N(l)?l:G(l)&&N(l.defaultValue)?l.defaultValue:Array.isArray(u)?u[u.length-1]:u,c=[o,{},!1];return c.t=o,c.i18n={},c.ready=!1,c}(z=s.options.react)!=null&&z.wait&&E(s,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const d={...F(),...s.options.react,...t},{useSuspense:w,keyPrefix:h}=d;let r=i||((O=s.options)==null?void 0:O.defaultNS);r=N(r)?[r]:r||["translation"],(v=(R=s.reportNamespaces).addUsedNamespaces)==null||v.call(R,r);const g=(s.isInitialized||s.initializedStoreOnce)&&r.every(o=>_(o,s,d)),U=J(s,t.lng||null,d.nsMode==="fallback"?r:r[0],h),b=()=>U,x=()=>P(s,t.lng||null,d.nsMode==="fallback"?r:r[0],h),[C,y]=f.useState(b);let p=r.join();t.lng&&(p=`${t.lng}${p}`);const I=D(p),m=f.useRef(!0);f.useEffect(()=>{const{bindI18n:o,bindI18nStore:c}=d;m.current=!0,!g&&!w&&(t.lng?A(s,t.lng,r,()=>{m.current&&y(x)}):S(s,r,()=>{m.current&&y(x)})),g&&I&&I!==p&&m.current&&y(x);const u=()=>{m.current&&y(x)};return o&&(s==null||s.on(o,u)),c&&(s==null||s.store.on(c,u)),()=>{m.current=!1,s&&o&&(o==null||o.split(" ").forEach(l=>s.off(l,u))),c&&s&&c.split(" ").forEach(l=>s.store.off(l,u))}},[s,p]),f.useEffect(()=>{m.current&&g&&y(b)},[s,h,g]);const T=[C,s,g];if(T.t=C,T.i18n=s,T.ready=g,g||!g&&!w)return T;throw new Promise(o=>{t.lng?A(s,t.lng,r,()=>o()):S(s,r,()=>o())})};export{X as g,Y as u};
